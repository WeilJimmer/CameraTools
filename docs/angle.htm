<!DOCTYPE html>
<html>
<head>
    <title>Lens Angle of View Calculator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif; 
            display: flex;
            flex-direction: row;
            height: 100vh;
            overflow: hidden;
            width: 100%;
        }

        .left-panel {
            width: 40%;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
            background-color: #fff;
        }

        .right-panel {
            width: 60%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f9f9f9;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        canvas {
            border: 1px solid #ccc;
            cursor: move;
            max-width: 95%;
            max-height: 95%;
        }

        input[type="number"] {
            width: 100px;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        label {
            min-width: 100px;
            display: inline-block;
        }

        select, input[type="text"] {
            min-width: 200px;
        }

        h2 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .layout-indicator {
            position: fixed;
            top: 5px;
            right: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 9999;
        }

        @media screen and (max-width: 500px) {
            body {
                flex-direction: column !important;
                height: auto !important;
                min-height: 100vh !important;
                overflow-y: auto !important;
            }

            .left-panel {
                width: 100% !important;
                max-width: 100% !important;
                height: auto !important;
                min-height: auto !important;
                border-right: none !important;
                border-bottom: 1px solid #ddd !important;
                order: 1 !important;
            }

            .right-panel {
                width: 100% !important;
                max-width: 100% !important;
                height: 700px !important;
                min-height: 700px !important;
                order: 2 !important;
            }

            .control-group {
                flex-direction: column !important;
                align-items: flex-start !important;
            }

            label {
                margin-bottom: 5px !important;
            }

            select, input[type="text"] {
                width: 100% !important;
                min-width: 0 !important;
            }
        }
    </style>
</head>
<body>
<div class="left-panel">
    <h2>Lens FOV Calculator</h2>
    <div class="controls">
        <div class="control-group">
            <label>CMOS：</label>
            <select id="sensorSize">
                <option value="MF_H">【53.40 mm x 40.00 mm】 Medium Format (Hasselblad H6D-100c) (4:3)</option>
                <option value="MF_PH">【44.00 mm x 33.00 mm】 Medium Format (Phase One, Hasselblad X1D) (4:3)</option>
                <option value="MF_GFX">【43.80 mm x 32.90 mm】 Medium Format (Fujifilm GFX) (4:3)</option>
                <option value="FF" selected="selected">【36.00 mm x 24.00 mm】 FullFrame (3:2)</option>
                <option value="APSH">【27.90 mm x 18.60 mm】 APS-H (3:2)</option>
                <option value="APSC_S">【23.60 mm x 15.60 mm】 APS-C (Sony,Fujifilm,Nikon) (3:2)</option>
                <option value="APSC_C">【22.20 mm x 14.80 mm】 APS-C Canon (3:2)</option>
                <option value="1_8in">【21.90 mm x 16.40 mm】 1.8″ (4:3)</option>
                <option value="1_7in">【20.80 mm x 15.60 mm】 1.7″ (4:3)</option>
                <option value="1_6in">【20.10 mm x 15.05 mm】 1.6″ (4:3)</option>
                <option value="1_5in">【18.70 mm x 14.00 mm】 1.5″ (4:3)</option>
                <option value="1_4in">【18.00 mm x 13.50 mm】 1.4″ (4:3)</option>
                <option value="M43">【17.30 mm x 13.00 mm】 M4/3 (4:3)</option>
                <option value="1_2in">【16.00 mm x 12.00 mm】 1.2″ (4:3)</option>
                <option value="1_1in">【14.70 mm x 11.00 mm】 1.1″ (4:3)</option>
                <option value="1inR32">【13.20 mm x 8.80 mm】 1″ (3:2)</option>
                <option value="1in">【12.80 mm x 9.60 mm】 1″ (4:3)</option>
                <option value="1in1_1">【11.60 mm x 8.70 mm】 1/1.1″ (4:3)</option>
                <option value="1in1_2">【10.67 mm x 8.00 mm】 1/1.2″ (4:3)</option>
                <option value="1in1_3">【9.60 mm x 7.20 mm】 1/1.3″ (4:3)</option>
                <option value="1in1_4">【8.90 mm x 6.67 mm】 1/1.4″ (4:3)</option>
                <option value="2in3">【8.80 mm x 6.60 mm】 2/3″ (4:3)</option>
                <option value="1in1_6">【8.00 mm x 6.00 mm】 1/1.6″ (4:3)</option>
                <option value="1in1_7">【7.60 mm x 5.70 mm】 1/1.7″ (4:3)</option>
                <option value="1in1_8">【7.20 mm x 5.40 mm】 1/1.8″ (4:3)</option>
                <option value="1in1_9">【6.80 mm x 5.10 mm】 1/1.9″ (4:3)</option>
                <option value="1in2">【6.67 mm x 5.00 mm】 1/2″ (4:3)</option>
                <option value="1in2_1">【6.40 mm x 4.80 mm】 1/2.1″ (4:3)</option>
                <option value="1in2_2">【6.16 mm x 4.62 mm】 1/2.2″ (4:3)</option>
                <option value="1in2_3">【6.00 mm x 4.50 mm】 1/2.3″ (4:3)</option>
                <option value="1in2_4">【5.90 mm x 4.43 mm】 1/2.4″ (4:3)</option>
                <option value="1in2_5">【5.76 mm x 4.29 mm】 1/2.5″ (4:3)</option>
                <option value="1in2_6">【5.50 mm x 4.10 mm】 1/2.6″ (4:3)</option>
                <option value="1in2_7">【5.30 mm x 4.00 mm】 1/2.7″ (4:3)</option>
                <option value="1in2_8">【5.10 mm x 3.83 mm】 1/2.8″ (4:3)</option>
                <option value="1in2_9">【4.90 mm x 3.67 mm】 1/2.9″ (4:3)</option>
                <option value="1in3">【4.80 mm x 3.60 mm】 1/3″ (4:3)</option>
                <option value="1in3_2">【4.54 mm x 3.42 mm】 1/3.2″ (4:3)</option>
                <option value="1in3_6">【4.00 mm x 3.00 mm】 1/3.6″ (4:3)</option>
                <option value="1in4">【3.60 mm x 2.70 mm】 1/4″ (4:3)</option>
                <option value="1in5">【2.88 mm x 2.16 mm】 1/5″ (4:3)</option>
            </select>
            <span data-title="CMOS sensor size does not refer to diagonal line but to the size of vacuum camera tubes, which is why a '1-inch' sensor actually measures 12.8 mm x 9.6 mm, with a diagonal of 0.63'' (16mm), not corresponding to the traditional meaning of a 1-inch sensor.">
                ℹ️
            </span>
        </div>
        <div class="control-group">
            <label>Focal Length：</label>
            <input type="number" id="focalLength" min="1" max="20000" value="50" step="1">
            <span>mm</span>
            <button id="addToCompareBtn">Add to Compare</button>
            <button onclick="document.getElementById('compareList').value='';state.compareList=[];updateUI();">Clear List</button>
        </div>
        <div class="control-group">
            <label>35mm Equivalent：</label>
            <span id="focalLengthRemark"></span>
        </div>
        <div class="control-group">
            <label>Angle of View：</label>
            <span id="angleDisplay">0</span>°
        </div>
        <div class="control-group">
            <label>Angle Type：</label>
            <div class="radio-group">
                <label class="radio-label">
                    <input type="radio" name="angleType" value="diagonal" checked> Diagonal
                </label>
                <label class="radio-label">
                    <input type="radio" name="angleType" value="horizontal"> Horizontal
                </label>
                <label class="radio-label">
                    <input type="radio" name="angleType" value="vertical"> Vertical
                </label>
            </div>
        </div>
        <div class="control-group">
            <label>FOV Comparison：</label>
            <input type="text" id="compareList" placeholder="FF/50,FF/85,APSC_S/35" value="FF/35,FF/50">
            <button onclick="reset()">Reset</button>
        </div>
        <div class="control-group">
            <label>Viewport Alignment:</label>
            <div class="radio-group">
                <label class="radio-label">
                    <input type="radio" name="positionType" value="center-center" checked> Center Center
                </label>
                <label class="radio-label">
                    <input type="radio" name="positionType" value="left-bottom"> Left Bottom
                </label>
                <label class="radio-label">
                    <input type="radio" name="positionType" value="left-center"> Left Center
                </label>
                <label class="radio-label">
                    <input type="radio" name="positionType" value="center-bottom"> Center Bottom
                </label>
            </div>
        </div>
        <div class="control-group">
            <label>Reference Image:</label>
            <input type="file" id="compareImage" accept="image/*">
            <button id="uploadBtn">Apply</button>
            <button id="clearBtn">Clear</button>
        </div>
        <div class="control-group">
            <label>Reference Image Opacity:</label>
            <input type="number" id="compareImageAlpha" min="1" max="100" value="60" step="1">
            <span>%</span>
            <input type="range" id="compareImageAlphaRange" min="1" max="100" value="60" step="1">
        </div>
        <br><br>
        <h2>Object Calculator (Experimental)</h2>
        <div class="control-group">
            <label>Reference Object:</label>
            <input type="checkbox" id="drawObjectChecked"> Draw Cuboid
        </div>
        <div class="control-group">
            <label>Object Width:</label>
            <input type="number" id="cuboidWidth" min="1" max="10000000" value="50" step="1">
            <select id="cuboidWidthUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidWidthRange" min="1" max="100" value="50" step="1">
        </div>
        <div class="control-group">
            <label>Object Height:</label>
            <input type="number" id="cuboidHeight" min="1" max="10000000" value="50" step="1">
            <select id="cuboidHeightUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidHeightRange" min="1" max="100" value="50" step="1">
        </div>
        <div class="control-group">
            <label>Object Depth:</label>
            <input type="number" id="cuboidDepth" min="1" max="10000000" value="50" step="1">
            <select id="cuboidDepthUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidDepthRange" min="1" max="100" value="50" step="1">
        </div>
        <div class="control-group">
            <label>Object X Position (Horizontal):</label>
            <input type="number" id="cuboidX" min="-10000000" max="10000000" value="0" step="1">
            <select id="cuboidXUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidXRange" min="-100" max="100" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Object Y Position (Vertical):</label>
            <input type="number" id="cuboidY" min="-10000000" max="10000000" value="0" step="1">
            <select id="cuboidYUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidYRange" min="-100" max="100" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Object Z Position (Distance):</label>
            <input type="number" id="cuboidZ" min="-10000000" max="10000000" value="1000" step="1">
            <select id="cuboidZUnit" style="min-width: 40px;">
                <option value="mm">mm</option>
                <option value="cm">cm</option>
                <option value="m">m</option>
                <option value="km">km</option>
                <option value="inch">inch</option>
                <option value="ft">ft</option>
                <option value="yd">yd</option>
                <option value="mile">mile</option>
            </select>
            <input type="range" id="cuboidZRange" min="-100" max="100" value="1000" step="1">
        </div>
    </div>
</div>
<div class="right-panel">
    <canvas id="canvas"></canvas>
</div>
    <script>
        class Cuboid {
            w = 50;
            h = 50;
            d = 50;
            x = 0;
            y = 0;
            z = 1000;
            points = [];
            angles = [];
            planes = [];
            constructor(w=50, h=50, d=50, x=0, y=0, z=1000) {
                this.w = w;
                this.h = h;
                this.d = d;
                this.x = x;
                this.y = y;
                this.z = z;
            }
            static getColorByDistance(index) {
                const colors = [80, 75, 65, 50, 45]
                return `hsl(0, 0%, ${colors[index]}%)`;
            }
            static getPlaneDistance(x, y, z) {
                return Math.sqrt(x ** 2 + y ** 2 + z ** 2);
            }
            static getTransformedPos(a, d){
                return Math.tan(verticalAngle * Math.PI / 360) * viewDistance * 2;
            }
            static getTransformedPoint(angles, distance) {
                let transformedPoints = angles.map(angle => {
                    let x = Math.tan(Math.abs(angle.h) * Math.PI / 360) * distance * (angle.h > 0 ? 1 : -1)
                    let y = Math.tan(Math.abs(angle.v) * Math.PI / 360) * distance * (angle.v > 0 ? 1 : -1);
                    return { x, y };
                });
                return transformedPoints;
            }
            static getAngleByDistance(x, y, distance, angleType='horizontal') {
                let size = Math.sqrt(x ** 2 + y ** 2);
                let direction = 1;
                if (angleType == 'horizontal') {
                    size = Math.abs(x);
                    direction = x < 0 ? -1 : 1;
                } else if (angleType == 'vertical') {
                    size = Math.abs(y);
                    direction = y < 0 ? -1 : 1;
                }
                return direction * 2 * Math.atan(size / (distance)) * 180 / Math.PI;
            }
            calculate(){
                this.generatePoints();
                this.generateAngles();
                return this;
            }
            generatePoints() {
                this.points = [
                    {x: this.x + this.w/2, y: this.y + this.h/2, z: this.z}, // right-bottom
                    {x: this.x - this.w/2, y: this.y + this.h/2, z: this.z}, // left-bottom
                    {x: this.x - this.w/2, y: this.y - this.h/2, z: this.z}, // left-top
                    {x: this.x + this.w/2, y: this.y - this.h/2, z: this.z}, // right-top
                    {x: this.x + this.w/2, y: this.y + this.h/2, z: this.z + this.d}, // right-bottom far
                    {x: this.x - this.w/2, y: this.y + this.h/2, z: this.z + this.d}, // left-bottom far
                    {x: this.x - this.w/2, y: this.y - this.h/2, z: this.z + this.d}, // left-top far
                    {x: this.x + this.w/2, y: this.y - this.h/2, z: this.z + this.d} // right-top far
                ];
                this.planes = [
                    { d: Cuboid.getPlaneDistance(this.x, this.y, this.z) }, // front
                    { d: Cuboid.getPlaneDistance(this.x - this.w/2, this.y, this.z + this.d/2) }, // left
                    { d: Cuboid.getPlaneDistance(this.x, this.y - this.h/2, this.z + this.d/2) }, // top
                    { d: Cuboid.getPlaneDistance(this.x + this.w/2, this.y, this.z + this.d/2) }, // right
                    { d: Cuboid.getPlaneDistance(this.x, this.y + this.h/2, this.z + this.d/2) },  // bottom
                    { d: Cuboid.getPlaneDistance(this.x, this.y, this.z + this.d) }, // back
                ];
            }
            generateAngles() {
                const left_front_ha = Cuboid.getAngleByDistance(this.x - this.w/2, 0, this.z, 'horizontal'); // left-front side horizontal angle
                const right_front_ha = Cuboid.getAngleByDistance(this.x + this.w/2, 0, this.z, 'horizontal'); // right-front side horizontal angle
                const top_front_va = Cuboid.getAngleByDistance(0, this.y - this.h/2, this.z, 'vertical'); // top-front side vertical angle
                const bottom_front_va = Cuboid.getAngleByDistance(0, this.y + this.h/2, this.z, 'vertical'); // bottom-front side vertical angle
                const left_rear_ha = Cuboid.getAngleByDistance(this.x - this.w/2, 0, this.z + this.d, 'horizontal'); // left-rear side horizontal angle
                const right_rear_ha = Cuboid.getAngleByDistance(this.x + this.w/2, 0, this.z + this.d, 'horizontal'); // right-rear side horizontal angle
                const top_rear_va = Cuboid.getAngleByDistance(0, this.y - this.h/2, this.z + this.d, 'vertical'); // top-rear side vertical angle
                const bottom_rear_va = Cuboid.getAngleByDistance(0, this.y + this.h/2, this.z + this.d, 'vertical'); // bottom-rear side vertical angle
                this.angles = [
                    { h: right_front_ha, v: bottom_front_va }, // right-bottom front [0]
                    { h: left_front_ha, v: bottom_front_va }, // left-bottom front [1]
                    { h: left_front_ha, v: top_front_va }, // left-top front [2]
                    { h: right_front_ha, v: top_front_va }, // right-top front [3]
                    { h: right_rear_ha, v: bottom_rear_va }, // right-bottom rear [4]
                    { h: left_rear_ha, v: bottom_rear_va }, // left-bottom rear [5]
                    { h: left_rear_ha, v: top_rear_va }, // left-top rear [6]
                    { h: right_rear_ha, v: top_rear_va } // right-top rear [7]
                ];
            }
            generate2DCuboid(distance) {
                const tps = Cuboid.getTransformedPoint(this.angles, distance);
                let planes2d = [
                    { d: this.planes[0].d, points: [tps[0], tps[1], tps[2], tps[3]], color: Cuboid.getColorByDistance(0) }, // front
                    { d: this.planes[1].d, points: [tps[1], tps[5], tps[6], tps[2]], color: Cuboid.getColorByDistance(2) }, // left
                    { d: this.planes[2].d, points: [tps[2], tps[3], tps[7], tps[6]], color: Cuboid.getColorByDistance(1) }, // top
                    { d: this.planes[3].d, points: [tps[3], tps[0], tps[4], tps[7]], color: Cuboid.getColorByDistance(2) }, // right
                    { d: this.planes[4].d, points: [tps[4], tps[5], tps[1], tps[0]], color: Cuboid.getColorByDistance(3) }, // bottom
                    { d: this.planes[5].d, points: [tps[4], tps[5], tps[6], tps[7]], color: Cuboid.getColorByDistance(4) } // back
                ]
                //sort by distance descending
                planes2d.sort((a, b) => b.d - a.d);
                return planes2d;
            }
        }
        const CONFIG = {
            SENSOR_TYPES: {
                MF_H: { width: 53.4, height: 40, label: 'Medium Format (4:3) Hasselblad H6D-100c', ratio: '4:3' },
                MF_PH: { width: 44, height: 33, label: 'Medium Format (4:3) Phase One', ratio: '4:3' },
                MF_GFX: { width: 43.8, height: 32.9, label: 'Medium Format (4:3) GFX', ratio: '4:3' },
                FF: { width: 36, height: 24, label: 'Full Frame (3:2)', ratio: '3:2' },
                APSH: { width: 27.9, height: 18.6, label: 'APS-H (3:2)', ratio: '3:2' },
                APSC_S: { width: 23.6, height: 15.6, label: 'APS-C (Sony, Fujifilm, Nikon) (3:2)', ratio: '3:2' },
                APSC_C: { width: 22.2, height: 14.8, label: 'APS-C (Canon) (3:2)', ratio: '3:2' },
                '1_8in': { width: 21.9, height: 16.4, label: '1.8" (4:3)', ratio: '4:3' },
                '1_7in': { width: 20.8, height: 15.6, label: '1.7" (4:3)', ratio: '4:3' },
                '1_6in': { width: 20.1, height: 15.05, label: '1.6" (4:3)', ratio: '4:3' },
                '1_5in': { width: 18.7, height: 14, label: '1.5" (4:3)', ratio: '4:3' },
                '1_4in': { width: 18.0, height: 13.5, label: '1.4" (4:3)', ratio: '4:3' },
                M43: { width: 17.3, height: 13, label: 'M43 (4:3)', ratio: '4:3' },
                '1_2in': { width: 16, height: 12, label: '1.2" (4:3)', ratio: '4:3' },
                '1_1in': { width: 14.7, height: 11, label: '1.1" (4:3)', ratio: '4:3' },
                '1inR32': { width: 13.2, height: 8.8, label: '1" (3:2)', ratio: '3:2' },
                '1in': { width: 12.8, height: 9.6, label: '1" (4:3)', ratio: '4:3' },
                '1in1_1': { width: 11.6, height: 8.7, label: '1/1.1" (4:3)', ratio: '4:3' },
                '1in1_2': { width: 10.67, height: 8, label: '1/1.2" (4:3)', ratio: '4:3' },
                '1in1_3': { width: 9.6, height: 7.2, label: '1/1.3" (4:3)', ratio: '4:3' },
                '1in1_4': { width: 8.9, height: 6.67, label: '1/1.4" (4:3)', ratio: '4:3' },
                '2in3': { width: 8.8, height: 6.6, label: '2/3" (4:3)', ratio: '4:3' },
                '1in1_6': { width: 8, height: 6, label: '1/1.6" (4:3)', ratio: '4:3' },
                '1in1_7': { width: 7.6, height: 5.7, label: '1/1.7" (4:3)', ratio: '4:3' },
                '1in1_8': { width: 7.2, height: 5.4, label: '1/1.8" (4:3)', ratio: '4:3' },
                '1in1_9': { width: 6.8, height: 5.1, label: '1/1.9" (4:3)', ratio: '4:3' },
                '1in2': { width: 6.67, height: 5.0, label: '1/2" (4:3)', ratio: '4:3' },
                '1in2_1': { width: 6.4, height: 4.8, label: '1/2.1" (4:3)', ratio: '4:3' },
                '1in2_2': { width: 6.16, height: 4.62, label: '1/2.2" (4:3)', ratio: '4:3' },
                '1in2_3': { width: 6.0, height: 4.5, label: '1/2.3" (4:3)', ratio: '4:3' },
                '1in2_4': { width: 5.9, height: 4.43, label: '1/2.4" (4:3)', ratio: '4:3' },
                '1in2_5': { width: 5.76, height: 4.29, label: '1/2.5" (4:3)', ratio: '4:3' },
                '1in2_6': { width: 5.5, height: 4.1, label: '1/2.6" (4:3)', ratio: '4:3' },
                '1in2_7': { width: 5.3, height: 4, label: '1/2.7" (4:3)', ratio: '4:3' },
                '1in2_8': { width: 5.1, height: 3.83, label: '1/2.8" (4:3)', ratio: '4:3' },
                '1in2_9': { width: 4.9, height: 3.67, label: '1/2.9" (4:3)', ratio: '4:3' },
                '1in3': { width: 4.8, height: 3.6, label: '1/3" (4:3)', ratio: '4:3' },
                '1in3_2': { width: 4.54, height: 3.42, label: '1/3.2" (4:3)', ratio: '4:3' },
                '1in3_6': { width: 4, height: 3, label: '1/3.6" (4:3)', ratio: '4:3' },
                '1in4': { width: 3.6, height: 2.7, label: '1/4" (4:3)', ratio: '4:3' },
                '1in5': { width: 2.88, height: 2.16, label: '1/5" (4:3)', ratio: '4:3' },
            },
            SCALE_FACTOR: 2, // CMOS 繪製放大倍數
            MIN_SCALE: 0.05,
            MAX_SCALE: 100,
            MIN_FOCAL: 1,
            MAX_FOCAL: 20000
        };

        // 應用狀態
        const state = {
            scale: 1,
            offset: { x: 0, y: 0 },
            focal: 50,
            sensor: 'FF',
            angleType: 'diagonal',
            positionType: 'center-center',
            drag: {
                active: false,
                focal: false,
                last: { x: 0, y: 0 }
            },
            compareList: [
                'FF/35',
                'FF/50',
            ],
            referenceImage: null,
            drawImage: true,
            imageAlpha: 0.6,
            drawObject: false,
            cuboid: (new Cuboid(50, 50, 50)).calculate(),
            units: {
                cuboidWidth: 'mm',
                cuboidHeight: 'mm',
                cuboidDepth: 'mm',
                cuboidX: 'mm',
                cuboidY: 'mm',
                cuboidZ: 'mm'
            },
        };

        // DOM 元素
        const elements = {
            canvas: document.getElementById('canvas'),
            sensor: document.getElementById('sensorSize'),
            focal: document.getElementById('focalLength'),
            focalRemark: document.getElementById('focalLengthRemark'),
            angle: document.getElementById('angleDisplay'),
            angleTypes: document.getElementsByName('angleType'),
            positionTypes: document.getElementsByName('positionType'),
            compareList: document.getElementById('compareList'),
            compareImage: document.getElementById('compareImage'),
            compareImageAlpha: document.getElementById('compareImageAlpha'),
            compareImageAlphaRange: document.getElementById('compareImageAlphaRange'),
            addToCompareBtn: document.getElementById('addToCompareBtn'),
            uploadBtn: document.getElementById('uploadBtn'),
            clearBtn: document.getElementById('clearBtn'),
            drawObjectChecked: document.getElementById('drawObjectChecked'),
            cuboidWidth: document.getElementById('cuboidWidth'),
            cuboidWidthUnit: document.getElementById('cuboidWidthUnit'),
            cuboidWidthRange: document.getElementById('cuboidWidthRange'),
            cuboidHeight: document.getElementById('cuboidHeight'),
            cuboidHeightUnit: document.getElementById('cuboidHeightUnit'),
            cuboidHeightRange: document.getElementById('cuboidHeightRange'),
            cuboidDepth: document.getElementById('cuboidDepth'),
            cuboidDepthUnit: document.getElementById('cuboidDepthUnit'),
            cuboidDepthRange: document.getElementById('cuboidDepthRange'),
            cuboidX: document.getElementById('cuboidX'),
            cuboidXUnit: document.getElementById('cuboidXUnit'),
            cuboidXRange: document.getElementById('cuboidXRange'),
            cuboidY: document.getElementById('cuboidY'),
            cuboidYUnit: document.getElementById('cuboidYUnit'),
            cuboidYRange: document.getElementById('cuboidYRange'),
            cuboidZ: document.getElementById('cuboidZ'),
            cuboidZUnit: document.getElementById('cuboidZUnit'),
            cuboidZRange: document.getElementById('cuboidZRange'),
        };
        const ctx = elements.canvas.getContext('2d');

        // 核心計算模組
        const calculator = {
            getAngle(sensorType='FF', angleType='diagonal', focal=50) {
                const sensor = CONFIG.SENSOR_TYPES[sensorType];
                const size = {
                    diagonal: Math.sqrt(sensor.width ** 2 + sensor.height ** 2),
                    horizontal: sensor.width,
                    vertical: sensor.height
                }[angleType];
                return 2 * Math.atan(size / (2 * focal)) * 180 / Math.PI;
            },

            getFFEquivalentFocal(angleDegree, angleType) {
                const ffSensor = CONFIG.SENSOR_TYPES['FF'];
                let sensorDimension = Math.sqrt(ffSensor.width ** 2 + ffSensor.height ** 2);
                if (angleType == 'horizontal') {
                    sensorDimension = ffSensor.width;
                } else if (angleType == 'vertical') {
                    sensorDimension = ffSensor.height;
                }
                const mmEquivalentFocal = sensorDimension / (2 * Math.tan(angleDegree * Math.PI / 360));
                return mmEquivalentFocal;
            },

            // 獲取基準位置
            getBasePosition() {
                return {
                    x: elements.canvas.width / 2,
                    y: elements.canvas.height / 2,
                    getFocalY() {
                        return this.y + 100 - state.focal * 2;
                    }
                };
            },

            // 從畫布座標轉換到視圖座標
            canvasToView(canvasX, canvasY) {
                return {
                    x: (canvasX - state.offset.x) / state.scale,
                    y: (canvasY - state.offset.y) / state.scale
                };
            },

            // 判斷點擊是否在焦點上
            isOnFocalPoint(canvasX, canvasY) {
                const view = this.canvasToView(canvasX, canvasY);
                const base = this.getBasePosition();
                return Math.abs(view.x - base.x) < 10 && Math.abs(view.y - base.getFocalY()) < 10;
            },

            // 從滑鼠Y座標計算焦距
            calculateFocal(canvasY) {
                const viewY = this.canvasToView(0, canvasY).y;
                const base = this.getBasePosition();
                return (base.y + 100 - viewY) / 2;
            },

            getUnitFactor(unit) {
                switch (unit) {
                    case 'mm': return 1;
                    case 'cm': return 10;
                    case 'm': return 1000;
                    case 'km': return 1000000;
                    case 'inch': return 25.4;
                    case 'ft': return 304.8;
                    case 'yd': return 914.4;
                    case 'mile': return 1609344;
                    default: return 1; // mm
                }
            },
        };

        // 繪圖模組
        const renderer = {

            clear() {
                ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            },

            withTransform(callback) {
                ctx.save();
                ctx.translate(state.offset.x, state.offset.y);
                ctx.scale(state.scale, state.scale);
                callback();
                ctx.restore();
            },

            focalLine(base) {
                ctx.beginPath();
                ctx.moveTo(base.x, base.y + 100);
                ctx.lineTo(base.x, base.getFocalY());
                ctx.strokeStyle = '#f00';
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f00';
                ctx.fillText('Focal Length', base.x + 10, (base.getFocalY() + base.y + 70) / 2);
                ctx.fillText(`${state.focal.toFixed(0)} mm`, base.x + 10, (base.getFocalY() + base.y + 100) / 2);
            },

            focalPoint(base) {
                ctx.beginPath();
                ctx.arc(base.x, base.getFocalY(), 5, 0, Math.PI * 2);
                ctx.fillStyle = '#f00';
                ctx.fill();
            },

            angleText(base) {
                ctx.font = '14px Arial';
                ctx.fillStyle = '#000';
                ctx.fillText(
                    `${calculator.getAngle(state.sensor, state.angleType, state.focal).toFixed(3)}°`,
                    base.x + 10,
                    base.getFocalY() - 10
                );
            },

            sensorAndAngle(base) {
                const sensor = CONFIG.SENSOR_TYPES[state.sensor];
                let sw = sensor.width;
                let sh = sensor.height;

                if (state.angleType == 'vertical') {
                    sw = sensor.height;
                    sh = sensor.width;
                }

                const w =  sw * CONFIG.SCALE_FACTOR;
                const h =  sh * CONFIG.SCALE_FACTOR;

                ctx.save();
                ctx.translate(base.x, base.y + 100);

                // 繪製 CMOS 邊框
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(-w/2, -h/2, w, h);

                // 繪製視角線
                ctx.beginPath();
                ctx.strokeStyle = '#0a0';
                ctx.lineWidth = 1;

                switch(state.angleType) {
                    case 'diagonal':
                        ctx.moveTo(-w/2, -h/2); // 左上角
                        ctx.lineTo(0, -state.focal * 2); // 焦點
                        ctx.lineTo(w/2, h/2); // 右下角
                        // 繪製對角線
                        ctx.moveTo(-w/2, -h/2); // 左上角
                        ctx.lineTo(w/2, h/2); // 右下角
                        break;
                    default: // horizontal or vertical
                        ctx.moveTo(-w/2, 0);
                        ctx.lineTo(0, -state.focal * 2);
                        ctx.lineTo(w/2, 0);
                        ctx.moveTo(-w/2, 0);
                        ctx.lineTo(w/2, 0);
                }
                ctx.stroke();

                // 繪製 CMOS Text
                ctx.font = '14px Arial';
                ctx.fillStyle = '#000';
                ctx.fillText(`${sw}mm`, -5, h/2 + 15);
                ctx.fillText(`${sh}mm`, w/2 + 5, 0);
                ctx.restore();
            },

            viewCompare(base) {
                const colors = ['#f00', '#080', '#00f', '#f80', '#f0f', '#08f', '#000', '#888', '#f0a', '#0af'];
                let centerX = base.x + 500;
                let centerY = base.y + 100;
                let viewDistance = 400; // 垂直距離
                let lineWidth = 0.5;
                let verifiedItems = state.compareList.map(item => {
                    const [sensor, focal] = item.split('/').map(i => i.trim());
                    if (CONFIG.SENSOR_TYPES[sensor] && !isNaN(focal) && parseFloat(focal) > 0) {
                        return { sensor, focal: parseFloat(focal) };
                    }
                    return null;
                }).filter(Boolean);
                let rects = [];
                while (true) {
                    rects = verifiedItems.map(item => {
                        let diagonalAngle = calculator.getAngle(item.sensor, 'diagonal', item.focal);
                        let horizontalAngle = calculator.getAngle(item.sensor, 'horizontal', item.focal);
                        let verticalAngle = calculator.getAngle(item.sensor, 'vertical', item.focal);
                        let w = Math.tan(horizontalAngle * Math.PI / 360) * viewDistance * 2;
                        let h = Math.tan(verticalAngle * Math.PI / 360) * viewDistance * 2;
                        console.log(item.sensor, item.focal, viewDistance, horizontalAngle, verticalAngle, w, h);
                        return {
                            width: w,
                            height: h,
                            focal: item.focal,
                            sensor: item.sensor,
                            angle: diagonalAngle,
                        };
                    });
                    if (rects.every(item => item.width > 5 && item.height > 5)) {
                        break;
                    }else{
                        viewDistance += 50;
                        console.log('auto adjust viewDistance', viewDistance);
                        if (viewDistance > 20000) {
                            console.error('無法計算視角，請檢查輸入的焦距和感光元件類型。');
                            break;
                        }
                    }
                    if (rects.length < 0) break;
                }
                if (rects.length<0) return;
                let space = viewDistance;
                for (let i = 0; i < rects.length; i++) {
                    if (space < (rects[i].width/2)) {
                        space = (rects[i].width/2);
                    }
                }
                centerX = base.x + space + 100;
                centerY = base.y + 100;
                if (state.positionType == 'left-bottom' || state.positionType == 'left-center') {
                    centerX -= rects[0].width/2;
                }
                if (state.positionType == 'center-bottom' || state.positionType == 'left-bottom') {
                    centerY += rects[0].height/2;
                }
                ctx.translate(centerX, centerY);
                if (state.drawObject) {
                    // drawing cuboid
                    const cuboid_planes = state.cuboid.calculate().generate2DCuboid(viewDistance);
                    cuboid_planes.forEach((plane, index) => {
                        ctx.beginPath();
                        ctx.strokeStyle = '#444';
                        ctx.lineWidth = 0.2;
                        ctx.fillStyle = plane.color;
                        ctx.moveTo(plane.points[0].x, plane.points[0].y);
                        for (let i = 1; i < plane.points.length; i++) {
                            ctx.lineTo(plane.points[i].x, plane.points[i].y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    });
                }
                rects.forEach((item, index) => {
                    let coodX = -item.width / 2;
                    let coodY = -item.height / 2;
                    if (state.positionType == 'left-bottom') {
                        coodX = 0;
                        coodY = -item.height;
                    } else if (state.positionType == 'left-center') {
                        coodX = 0;
                        coodY = -item.height / 2;
                    } else if (state.positionType == 'center-bottom') {
                        coodX = -item.width / 2;
                        coodY = -item.height;
                    }
                    if (index == 0 && state.drawImage && state.referenceImage) {
                        ctx.globalAlpha = state.imageAlpha;
                        ctx.drawImage(state.referenceImage, coodX, coodY, item.width, item.height);
                        ctx.globalAlpha = 1.0;
                    }
                    ctx.strokeStyle = colors[index % colors.length];
                    ctx.lineWidth = lineWidth;
                    ctx.strokeRect(coodX, coodY, item.width, item.height);
                    ctx.fillStyle = ctx.strokeStyle
                    let ffeq = calculator.getFFEquivalentFocal(item.angle, 'diagonal').toFixed(1);
                    if (item.sensor != 'FF') {
                        ctx.fillText(`${CONFIG.SENSOR_TYPES[item.sensor].label} ${item.focal}mm 〔≈${ffeq}mm EFL〕`, coodX + 5, coodY - 5);
                    }else{
                        ctx.fillText(`${CONFIG.SENSOR_TYPES[item.sensor].label} ${item.focal}mm`, coodX + 5, coodY - 5);
                    }
                });
                ctx.save();
                ctx.restore();
            }
        };

        // 繪製全部內容
        function render() {
            renderer.clear();
            renderer.withTransform(() => {
                const base = calculator.getBasePosition();
                renderer.sensorAndAngle(base);
                renderer.focalLine(base);
                renderer.focalPoint(base);
                renderer.angleText(base);
                renderer.viewCompare(base);
            });
        }

        // 更新UI顯示
        function updateUI() {
            if (state.sensor !== 'FF') {
                let angle_ori = calculator.getAngle(state.sensor, state.angleType, state.focal).toFixed(3);
                let mm_ff = calculator.getFFEquivalentFocal(angle_ori, state.angleType);
                let ratio = parseFloat((mm_ff / state.focal).toFixed(3));
                elements.focalRemark.textContent = `${mm_ff.toFixed(3)}mm (~${ratio.toFixed(1)}x)`;
            } else {
                elements.focalRemark.textContent = state.focal.toFixed(0) + 'mm';
            }
            elements.angle.textContent = calculator.getAngle(state.sensor, state.angleType, state.focal).toFixed(5);
            render();
        }

        function reset() {
            state.sensor = 'FF';
            state.focal = 50;
            state.angleType = 'diagonal';
            state.compareList = [];
            state.positionType = 'center-center';
            state.offset = { x: 0, y: 0 };
            state.scale = 1;
            elements.sensor.value = 'FF';
            elements.focal.value = 50;
            elements.angleTypes[0].checked = true;
            elements.positionTypes[0].checked = true;
            elements.compareList.value = '';
            updateUI();
        }

        // 事件處理模組
        const eventHandlers = {
            mousedown(e) {
                const rect = elements.canvas.getBoundingClientRect();
                const canvasX = e.clientX - rect.left;
                const canvasY = e.clientY - rect.top;
                state.drag.active = true;
                state.drag.focal = calculator.isOnFocalPoint(canvasX, canvasY);
                state.drag.last = { x: e.clientX, y: e.clientY };
            },

            mousemove(e) {
                if (!state.drag.active) return;

                if (state.drag.focal) {
                    const rect = elements.canvas.getBoundingClientRect();
                    const canvasY = e.clientY - rect.top;
                    const newFocal = calculator.calculateFocal(canvasY);
                    state.focal = Math.max(CONFIG.MIN_FOCAL, Math.min(CONFIG.MAX_FOCAL, newFocal));
                    elements.focal.value = Math.round(state.focal);
                } else {
                    const dx = e.clientX - state.drag.last.x;
                    const dy = e.clientY - state.drag.last.y;
                    state.offset.x += dx;
                    state.offset.y += dy;
                    state.drag.last = { x: e.clientX, y: e.clientY };
                }
                updateUI();
            },

            mouseup() {
                state.drag.active = false;
                state.drag.focal = false;
            },

            wheel(e) {
                e.preventDefault();
                const rect = elements.canvas.getBoundingClientRect();

                // 滑鼠相對於畫布的位置
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // 計算滑鼠位置在縮放前的坐標系中的位置
                const viewX = (mouseX - state.offset.x) / state.scale;
                const viewY = (mouseY - state.offset.y) / state.scale;

                // 計算新的縮放比例
                const delta = -Math.sign(e.deltaY) * 0.1;
                const newScale = Math.max(CONFIG.MIN_SCALE, Math.min(CONFIG.MAX_SCALE, state.scale + delta));

                // 調整偏移量以保持滑鼠指針下方的點不變
                state.offset.x = mouseX - viewX * newScale;
                state.offset.y = mouseY - viewY * newScale;

                state.scale = newScale;
                render();
            }
        };

        // 初始化應用
        function initialize() {
            // 設置畫布大小
            function resizeCanvas() {
                const rightPanel = document.querySelector('.right-panel');
                const padding = 20;
                const availableWidth = rightPanel.clientWidth - (padding * 2);
                const availableHeight = rightPanel.clientHeight - (padding * 2);
                elements.canvas.width = availableWidth;
                elements.canvas.height = availableHeight;
            }

            // 添加事件監聽器
            function setupEventListeners() {
                elements.canvas.addEventListener('mousedown', eventHandlers.mousedown);
                elements.canvas.addEventListener('mousemove', eventHandlers.mousemove);
                elements.canvas.addEventListener('mouseup', eventHandlers.mouseup);
                elements.canvas.addEventListener('mouseleave', eventHandlers.mouseup);
                elements.canvas.addEventListener('wheel', eventHandlers.wheel);

                elements.sensor.addEventListener('change', e => {
                    state.sensor = e.target.value;
                    updateUI();
                });

                elements.focal.addEventListener('input', e => {
                    state.focal = Math.max(CONFIG.MIN_FOCAL, Math.min(CONFIG.MAX_FOCAL, Number(e.target.value)));
                    updateUI();
                });

                elements.angleTypes.forEach(input => {
                    input.addEventListener('change', e => {
                        state.angleType = e.target.value;
                        updateUI();
                    });
                });

                elements.positionTypes.forEach(input => {
                    input.addEventListener('change', e => {
                        state.positionType = e.target.value;
                        updateUI();
                    });
                });

                elements.compareList.addEventListener('input', e => {
                    state.compareList = e.target.value.split(',').map(item => item.trim()).filter(Boolean);
                    updateUI();
                });

                elements.compareImage.addEventListener('change', e => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onloadend = function() {
                            state.referenceImage = new Image();
                            state.referenceImage.src = reader.result;
                            state.drawImage = true;
                            render();
                        };
                        reader.readAsDataURL(file);
                    }
                });

                elements.compareImageAlpha.addEventListener('input', e => {
                    state.imageAlpha = Math.max(1, Number(e.target.value)) * 0.01;
                    elements.compareImageAlphaRange.value = e.target.value;
                    render();
                });

                elements.compareImageAlphaRange.addEventListener('input', e => {
                    state.imageAlpha = Math.max(1, Number(e.target.value)) * 0.01;
                    elements.compareImageAlpha.value = e.target.value;
                    render();
                });

                elements.uploadBtn.addEventListener('click', () => {
                    if (state.referenceImage) {
                        state.drawImage = true;
                        render();
                    }
                });

                elements.clearBtn.addEventListener('click', () => {
                    state.drawImage = false;
                    render();
                });

                elements.addToCompareBtn.addEventListener('click', () => {
                    const sensor = state.sensor;
                    const focal = state.focal;
                    state.compareList.push(`${sensor}/${focal.toFixed(0)}`);
                    state.compareList = [...new Set(state.compareList)]; // 去重
                    elements.compareList.value = state.compareList.join(',');
                    updateUI();
                });

                elements.drawObjectChecked.addEventListener('change', e => {
                    state.drawObject = e.target.checked;
                    render();
                });

                elements.cuboidWidth.addEventListener('input', e => {
                    state.cuboid.w = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidWidthUnit);
                    updateUI();
                });

                elements.cuboidWidthRange.addEventListener('input', e => {
                    state.cuboid.w = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidWidthUnit);
                    elements.cuboidWidth.value = state.cuboid.w / calculator.getUnitFactor(state.units.cuboidWidthUnit);
                    updateUI();
                });

                elements.cuboidWidthUnit.addEventListener('change', e => {
                    state.units.cuboidWidthUnit = e.target.value;
                    state.cuboid.w = Math.max(1, Number(elements.cuboidWidth.value)) * calculator.getUnitFactor(state.units.cuboidWidthUnit);
                    elements.cuboidWidthRange.value = state.cuboid.w / calculator.getUnitFactor(state.units.cuboidWidthUnit);
                    updateUI();
                });

                elements.cuboidHeight.addEventListener('input', e => {
                    state.cuboid.h = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidHeightUnit);
                    updateUI();
                });

                elements.cuboidHeightRange.addEventListener('input', e => {
                    state.cuboid.h = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidHeightUnit);
                    elements.cuboidHeight.value = state.cuboid.h / calculator.getUnitFactor(state.units.cuboidHeightUnit);
                    updateUI();
                });

                elements.cuboidHeightUnit.addEventListener('change', e => {
                    state.units.cuboidHeightUnit = e.target.value;
                    state.cuboid.h = Math.max(1, Number(elements.cuboidHeight.value)) * calculator.getUnitFactor(state.units.cuboidHeightUnit);
                    elements.cuboidHeightRange.value = state.cuboid.h / calculator.getUnitFactor(state.units.cuboidHeightUnit);
                    updateUI();
                });

                elements.cuboidDepth.addEventListener('input', e => {
                    state.cuboid.d = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidDepthUnit);
                    updateUI();
                });

                elements.cuboidDepthRange.addEventListener('input', e => {
                    state.cuboid.d = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidDepthUnit);
                    elements.cuboidDepth.value = state.cuboid.d / calculator.getUnitFactor(state.units.cuboidDepthUnit);
                    updateUI();
                });

                elements.cuboidDepthUnit.addEventListener('change', e => {
                    state.units.cuboidDepthUnit = e.target.value;
                    state.cuboid.d = Math.max(0, Number(elements.cuboidDepth.value)) * calculator.getUnitFactor(state.units.cuboidDepthUnit);
                    elements.cuboidDepthRange.value = state.cuboid.d / calculator.getUnitFactor(state.units.cuboidDepthUnit);
                    updateUI();
                });

                elements.cuboidX.addEventListener('input', e => {
                    state.cuboid.x = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidXUnit);
                    updateUI();
                });

                elements.cuboidXRange.addEventListener('input', e => {
                    state.cuboid.x = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidXUnit);
                    elements.cuboidX.value = state.cuboid.x / calculator.getUnitFactor(state.units.cuboidXUnit);
                    updateUI();
                });

                elements.cuboidXUnit.addEventListener('change', e => {
                    state.units.cuboidXUnit = e.target.value;
                    state.cuboid.x = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidXUnit);
                    elements.cuboidXRange.value = state.cuboid.x / calculator.getUnitFactor(state.units.cuboidXUnit);
                    updateUI();
                });

                elements.cuboidY.addEventListener('input', e => {
                    state.cuboid.y = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidYUnit);
                    updateUI();
                });

                elements.cuboidYRange.addEventListener('input', e => {
                    state.cuboid.y = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidYUnit);
                    elements.cuboidY.value = state.cuboid.y / calculator.getUnitFactor(state.units.cuboidYUnit);
                    updateUI();
                });

                elements.cuboidYUnit.addEventListener('change', e => {
                    state.units.cuboidYUnit = e.target.value;
                    state.cuboid.y = Number(e.target.value) * calculator.getUnitFactor(state.units.cuboidYUnit);
                    elements.cuboidYRange.value = state.cuboid.y / calculator.getUnitFactor(state.units.cuboidYUnit);
                    updateUI();
                });

                elements.cuboidZ.addEventListener('input', e => {
                    state.cuboid.z = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidZUnit);
                    updateUI();
                });

                elements.cuboidZRange.addEventListener('input', e => {
                    state.cuboid.z = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidZUnit);
                    elements.cuboidZ.value = state.cuboid.z / calculator.getUnitFactor(state.units.cuboidZUnit);
                    updateUI();
                });

                elements.cuboidZUnit.addEventListener('change', e => {
                    state.units.cuboidZUnit = e.target.value;
                    state.cuboid.z = Math.max(1, Number(e.target.value)) * calculator.getUnitFactor(state.units.cuboidZUnit);
                    elements.cuboidZRange.value = state.cuboid.z / calculator.getUnitFactor(state.units.cuboidZUnit);
                    updateUI();
                });

                window.addEventListener('resize', () => {
                    resizeCanvas();
                    render();
                });
            }

            resizeCanvas();
            setupEventListeners();
            updateUI();
        }

        // 啟動應用
        initialize();

        document.addEventListener('DOMContentLoaded', function() {
            const tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.style.position = 'absolute';
            tooltip.style.display = 'none';
            tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            tooltip.style.color = 'white';
            tooltip.style.padding = '5px 10px';
            tooltip.style.borderRadius = '4px';
            tooltip.style.fontSize = '14px';
            tooltip.style.zIndex = '10000';
            tooltip.style.pointerEvents = 'none';
            document.body.appendChild(tooltip);
            const elementsWithTooltips = document.querySelectorAll('[data-title]');
            elementsWithTooltips.forEach(element => {
                element.addEventListener('mouseover', function(e) {
                    const title = this.getAttribute('data-title');
                    if (title) {
                        tooltip.textContent = title;
                        tooltip.style.display = 'block';
                        updateTooltipPosition(e);
                    }
                });
                element.addEventListener('mousemove', function(e) {
                    updateTooltipPosition(e);
                });
                element.addEventListener('mouseout', function() {
                    tooltip.style.display = 'none';
                });
            });
            function updateTooltipPosition(e) {
                const x = e.clientX + 10;
                const y = e.clientY + 10;
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
                const tooltipRect = tooltip.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                if (tooltipRect.right > windowWidth) {
                    tooltip.style.left = (windowWidth - tooltipRect.width - 10) + 'px';
                }
                if (tooltipRect.bottom > windowHeight) {
                    tooltip.style.top = (windowHeight - tooltipRect.height - 10) + 'px';
                }
            }
        });
    </script>
</body>
</html>